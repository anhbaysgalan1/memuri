name: CI/CD Pipeline

on:
  push:
    branches:
      - main

jobs:
  build-test-publish:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # To allow committing and pushing version bumps
      packages: write  # If you were publishing to GitHub Packages (not the case here, but good practice if ever needed)
    
    # Define services (containers) that will run alongside the job
    services:
      # PostgreSQL with pgvector service
      postgres:
        image: pgvector/pgvector:pg17
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpassword
          POSTGRES_DB: testdb
        ports:
          - 5432:5432
        # Health check to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      # Redis service
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        # Health check to wait until redis has started
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Poetry
        uses: snok/install-poetry@v1.3.1
        with:
          virtualenvs-in-project: true

      - name: Cache Poetry virtualenv
        uses: actions/cache@v3 # Using v3 as v4 is still in beta
        with:
          path: .venv
          key: ${{ runner.os }}-poetry-${{ hashFiles('**/poetry.lock') }}
          restore-keys: |
            ${{ runner.os }}-poetry-

      - name: Install Dependencies
        run: poetry install --with dev --no-interaction --no-ansi

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update -y
          sudo apt-get install -y postgresql-client

      - name: Initialize pgvector extension
        run: |
          # Create pgvector extension
          PGPASSWORD=memuri psql -h localhost -U memuri -d memuri -c "CREATE EXTENSION IF NOT EXISTS vector;"
          echo "pgvector extension created successfully"

      - name: Verify PostgreSQL connection
        run: |
          # Verify the PostgreSQL connection using the correct user
          PGPASSWORD=testpassword psql -h localhost -U testuser -d testdb -c "\dx"
          echo "PostgreSQL is ready with pgvector extension"

      - name: Verify Redis connection
        run: |
          # Verify the Redis connection
          redis-cli ping
          echo "Redis is ready"

      - name: Linting
        run: poetry run flake8 src/memuri

      - name: Type Checking
        run: poetry run mypy src/memuri

      - name: Testing
        id: tests # Add an id to refer to the outcome of this step
        run: poetry run pytest --cov=memuri
        env:
          # Updated to use standardized environment variables (single underscore format)
          MEMURI_DATABASE_POSTGRES_URL: postgresql://testuser:testpassword@localhost:5432/testdb
          MEMURI_REDIS_REDIS_URL: redis://localhost:6379/0
          MEMURI_VECTOR_STORE_PROVIDER: pgvector
          MEMURI_VECTOR_STORE_DIMENSION: 1536
          MEMURI_VECTOR_STORE_CONNECTION_STRING: postgresql://testuser:testpassword@localhost:5432/testdb
          MEMURI_VECTOR_STORE_COLLECTION_NAME: test_memories
          MEMURI_LLM_API_KEY: ${{ secrets.MEMURI_LLM_API_KEY }}
          MEMURI_EMBEDDING_API_KEY: ${{ secrets.MEMURI_LLM_API_KEY }}
          MEMURI_EMBEDDING_PROVIDER: openai
          MEMURI_EMBEDDING_MODEL_NAME: text-embedding-3-small

      - name: Configure Git User
        if: success() && steps.tests.outcome == 'success' # Run only if tests pass
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"

      - name: Determine and Bump Version
        if: success() && steps.tests.outcome == 'success' # Run only if tests pass
        id: version_bump # Add an id to refer to the outcome of this step
        run: |
          # Assuming pyproject.toml is in the root
          # This is a simplified way to get the version. A more robust way might be needed.
          BASE_VERSION=$(poetry version -s)
          # Calculate next dev version
          NEXT_DEV_VERSION="${BASE_VERSION}.dev$(git rev-list --count HEAD)"
          echo "Calculated version: $NEXT_DEV_VERSION"
          poetry version $NEXT_DEV_VERSION
          echo "new_version=$(poetry version -s)" >> $GITHUB_OUTPUT


      - name: Build Package
        if: success() && steps.tests.outcome == 'success' # Run only if tests pass
        run: poetry build

      - name: Publish to PyPI
        if: success() && steps.tests.outcome == 'success' # Run only if tests pass
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          user: __token__
          password: ${{ secrets.PYPI_API_TOKEN }}
          skip_existing: true

      - name: Commit Version Bump
        if: success() && steps.tests.outcome == 'success' && steps.version_bump.outcome == 'success' # Run only if publish was successful (implicitly, if previous steps succeeded)
        run: |
          git add pyproject.toml poetry.lock
          # Use the version output from the version_bump step
          git commit -m "Automated version bump to ${{ steps.version_bump.outputs.new_version }} [skip ci]"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # GITHUB_TOKEN is required to push to the repository