name: CI/CD Pipeline

on:
  push:
    branches:
      - main

jobs:
  build-test-publish:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # To allow committing and pushing version bumps
      packages: write  # If you were publishing to GitHub Packages (not the case here, but good practice if ever needed)
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Poetry
        uses: snok/install-poetry@v1.3.1
        with:
          virtualenvs-in-project: true

      - name: Cache Poetry virtualenv
        uses: actions/cache@v3 # Using v3 as v4 is still in beta
        with:
          path: .venv
          key: ${{ runner.os }}-poetry-${{ hashFiles('**/poetry.lock') }}
          restore-keys: |
            ${{ runner.os }}-poetry-

      - name: Install Dependencies
        run: poetry install --with dev --no-interaction --no-ansi

      - name: Set up PostgreSQL with pgvector
        uses: docker/setup-buildx-action@v3
        
      - name: Run PostgreSQL with pgvector
        uses: docker/run-action@v2
        with:
          image: pgvector/pgvector:pg17
          options: >-
            --name postgresql
            -p 5432:5432
            -e POSTGRES_USER=testuser
            -e POSTGRES_PASSWORD=testpassword
            -e POSTGRES_DB=testdb
          detached: true # Run in detached mode

      - name: Wait for PostgreSQL to be ready
        run: |
          # Wait for PostgreSQL to be ready
          timeout=60
          until pg_isready -h localhost -p 5432 -U testuser || [ $timeout -eq 0 ]; do
            sleep 1
            ((timeout--))
          done
          if [ $timeout -eq 0 ]; then
            echo "Timed out waiting for PostgreSQL to be ready"
            exit 1
          fi
          echo "PostgreSQL is ready"

      - name: Set up Redis
        uses: docker/run-action@v2
        with:
          image: redis:7-alpine
          options: >-
            --name redis
            -p 6379:6379
          detached: true

      - name: Wait for Redis to be ready
        run: |
          # Wait for Redis to be ready
          timeout=30
          until redis-cli ping || [ $timeout -eq 0 ]; do
            sleep 1
            ((timeout--))
          done
          if [ $timeout -eq 0 ]; then
            echo "Timed out waiting for Redis to be ready"
            exit 1
          fi
          echo "Redis is ready"

      - name: Linting
        run: poetry run flake8 src/memuri

      - name: Type Checking
        run: poetry run mypy src/memuri

      - name: Testing
        id: tests # Add an id to refer to the outcome of this step
        run: poetry run pytest --cov=memuri
        env:
          # Updated to use standardized environment variables (single underscore format)
          MEMURI_DATABASE_POSTGRES_URL: postgresql://testuser:testpassword@localhost:5432/testdb
          MEMURI_REDIS_REDIS_URL: redis://localhost:6379/0
          MEMURI_VECTOR_STORE_PROVIDER: pgvector
          MEMURI_VECTOR_STORE_DIMENSION: 1536
          MEMURI_VECTOR_STORE_CONNECTION_STRING: postgresql://testuser:testpassword@localhost:5432/testdb
          MEMURI_VECTOR_STORE_COLLECTION_NAME: test_memories
          MEMURI_LLM_API_KEY: ${{ secrets.MEMURI_LLM_API_KEY }}
          MEMURI_EMBEDDING_API_KEY: ${{ secrets.MEMURI_LLM_API_KEY }}
          MEMURI_EMBEDDING_PROVIDER: openai
          MEMURI_EMBEDDING_MODEL_NAME: text-embedding-3-small

      - name: Configure Git User
        if: success() && steps.tests.outcome == 'success' # Run only if tests pass
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"

      - name: Determine and Bump Version
        if: success() && steps.tests.outcome == 'success' # Run only if tests pass
        id: version_bump # Add an id to refer to the outcome of this step
        run: |
          # Assuming pyproject.toml is in the root
          # This is a simplified way to get the version. A more robust way might be needed.
          BASE_VERSION=$(poetry version -s)
          # Calculate next dev version
          NEXT_DEV_VERSION="${BASE_VERSION}.dev$(git rev-list --count HEAD)"
          echo "Calculated version: $NEXT_DEV_VERSION"
          poetry version $NEXT_DEV_VERSION
          echo "new_version=$(poetry version -s)" >> $GITHUB_OUTPUT


      - name: Build Package
        if: success() && steps.tests.outcome == 'success' # Run only if tests pass
        run: poetry build

      - name: Publish to PyPI
        if: success() && steps.tests.outcome == 'success' # Run only if tests pass
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          user: __token__
          password: ${{ secrets.PYPI_API_TOKEN }}
          skip_existing: true

      - name: Commit Version Bump
        if: success() && steps.tests.outcome == 'success' && steps.version_bump.outcome == 'success' # Run only if publish was successful (implicitly, if previous steps succeeded)
        run: |
          git add pyproject.toml poetry.lock
          # Use the version output from the version_bump step
          git commit -m "Automated version bump to ${{ steps.version_bump.outputs.new_version }} [skip ci]"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # GITHUB_TOKEN is required to push to the repository